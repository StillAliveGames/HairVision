# Документация
## Базовая часть

Создаём дизайн сайта в фигме: определяем структуру и разделы сайта. Затем создаём статический веб-сайт: настраиваем базовую вёрстку, добавляем шрифты, анимируем элементы.


## Вариативная часть

## Общее описание
Код реализует замену прически между двумя изображениями (source и target) с использованием нейросетевой сегментации и компьютерного зрения. Основные этапы:
1. Сегментация волос на исходном и целевом изображениях
2. Очистка исходного изображения от исходной прически
3. Определение оптимальной позиции для вставки новой прически
4. Смешивание изображений с использованием продвинутых техник

## Требования
1. Зависимости:
   ```
   opencv-python
   numpy
   torch
   mediapipe
   ```
2. Файл модели: `u2net.pth` в корневой директории
3. Структура папок:
   - `input/` - исходные изображения (source.jpg, target.jpg)
   - `output/` - результаты работы программы

## Функции

### `load_model()`
**Назначение**: Загрузка предобученной модели U²-Net  
**Возвращает**:  
- `model` (U2NET) - загруженная модель

**Исключения**:
- `FileNotFoundError` если файл модели не найден

---

### `process_mask(mask, kernel_size=5)`
**Назначение**: Постобработка маски сегментации  
**Параметры**:
- `mask` (numpy.ndarray) - исходная бинарная маска
- `kernel_size` (int) - размер ядра для морфологических операций

**Возвращает**:
- Обработанная маска (numpy.ndarray)

---

### `segment_hair(model, image, threshold=0.7)`
**Назначение**: Сегментация волос на изображении  
**Параметры**:
- `model` (U2NET) - модель для сегментации
- `image` (numpy.ndarray) - входное изображение BGR
- `threshold` (float) - порог бинаризации (0.0-1.0)

**Возвращает**:
- Бинарную маску волос (numpy.ndarray) размером исходного изображения

---

### `safe_resize(img, size)`
**Назначение**: Масштабирование с сохранением пропорций  
**Параметры**:
- `img` (numpy.ndarray) - входное изображение
- `size` (int) - целевой размер (максимальная сторона)

**Возвращает**:
- Масштабированное изображение (numpy.ndarray)

---

### `detect_face_center(image)`
**Назначение**: Поиск центра лица для позиционирования прически  
**Параметры**:
- `image` (numpy.ndarray) - входное изображение BGR

**Возвращает**:
- Кортеж (x, y) координат центра или None при ошибке

---

### `blend_images(src, dst, mask)`
**Назначение**: Альтернативное смешивание изображений  
**Параметры**:
- `src` (numpy.ndarray) - изображение для вставки
- `dst` (numpy.ndarray) - фоновое изображение
- `mask` (numpy.ndarray) - маска смешивания

**Возвращает**:
- Смешанное изображение (numpy.ndarray)

---

### `swap_hair(source_path, target_path)`
**Назначение**: Основная функция замены прически  
**Параметры**:
- `source_path` (str) - путь к исходному изображению
- `target_path` (str) - путь к изображению с целевой прической

**Выполняемые операции**:
1. Загрузка и предобработка изображений
2. Генерация масок сегментации
3. Очистка исходного изображения
4. Определение позиции для вставки
5. Два метода смешивания:
   - `seamlessClone` (приоритетный)
   - Ручное альфа-смешивание (резервный)

**Сохранение результатов**:
1. `1_source_mask.jpg` - маска исходной прически
2. `2_target_mask.jpg` - маска целевой прически
3. `3_cleaned.jpg` - очищенное исходное изображение
4. `4_center.jpg` - визуализация центра вставки
5. `5_result.jpg` - финальный результат

**Исключения**:
- `ValueError` при проблемах с загрузкой изображений
- Ошибки обработки с подробным выводом в консоль

---

## Пример использования
```python
swap_hair(
    os.path.join("input", "source.jpg"),
    os.path.join("input", "target.jpg")
)
```

## Рекомендации
1. Изображения должны быть хорошо освещены
2. Лицо должно занимать не менее 30% площади изображения
3. Для лучших результатов использовать изображения с разрешением 512x512
4. Прически должны быть сопоставимы по размеру и ракурсу

## Ограничения
- Требуется GPU для быстрой работы
- Может некорректно работать с сложными прическами
- Возможны артефакты при сильном различии освещения

